#!/usr/bin/env python3
"""
Script to plot observations and actions data from CSV logs generated by play.py
"""

import argparse
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
from pathlib import Path
import seaborn as sns

def plot_csv_data(csv_path, output_dir=None, show_plots=True):
    """
    Plot observations and actions from CSV file
    
    Args:
        csv_path (str): Path to the CSV file
        output_dir (str): Directory to save plots (optional)
        show_plots (bool): Whether to display plots interactively
    """
    # Read the CSV data
    print(f"Loading data from: {csv_path}")
    df = pd.read_csv(csv_path)
    
    # Extract observations and actions columns
    obs_columns = [col for col in df.columns if col.startswith('obs_')]
    action_columns = [col for col in df.columns if col.startswith('action_')]
    
    print(f"Found {len(obs_columns)} observation dimensions and {len(action_columns)} action dimensions")
    print(f"Total timesteps: {len(df)}")
    
    # Set up the plotting style
    plt.style.use('seaborn-v0_8')
    sns.set_palette("husl")
    
    # Create output directory if specified
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
    
    # Plot 1: Observations over time
    if obs_columns:
        fig, axes = plt.subplots(figsize=(12, 8))
        
        # If too many observations, plot only first 10 and last 10
        if len(obs_columns) > 20:
            plot_obs = obs_columns[:10] + obs_columns[-10:]
            print(f"Too many observation dimensions ({len(obs_columns)}). Plotting first 10 and last 10.")
        else:
            plot_obs = obs_columns
        
        for col in plot_obs:
            plt.plot(df['sim_time'], df[col], label=col, alpha=0.7, linewidth=1)
        
        plt.xlabel('Simulation Time (s)')
        plt.ylabel('Observation Values')
        plt.title('Observations Over Time')
        plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        
        if output_dir:
            plt.savefig(os.path.join(output_dir, 'observations_time_series.png'), dpi=300, bbox_inches='tight')
        if show_plots:
            plt.show()
        else:
            plt.close()
    
    # Plot 2: Actions over time
    if action_columns:
        fig, axes = plt.subplots(figsize=(12, 6))
        
        for col in action_columns:
            plt.plot(df['sim_time'], df[col], label=col, linewidth=2)
        
        plt.xlabel('Simulation Time (s)')
        plt.ylabel('Action Values')
        plt.title('Actions Over Time')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        
        if output_dir:
            plt.savefig(os.path.join(output_dir, 'actions_time_series.png'), dpi=300, bbox_inches='tight')
        if show_plots:
            plt.show()
        else:
            plt.close()
    
    # Plot 3: Action distribution histograms
    if action_columns:
        n_actions = len(action_columns)
        fig, axes = plt.subplots(1, n_actions, figsize=(4*n_actions, 4))
        if n_actions == 1:
            axes = [axes]
        
        for i, col in enumerate(action_columns):
            axes[i].hist(df[col], bins=30, alpha=0.7, edgecolor='black')
            axes[i].set_title(f'{col} Distribution')
            axes[i].set_xlabel('Action Value')
            axes[i].set_ylabel('Frequency')
            axes[i].grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if output_dir:
            plt.savefig(os.path.join(output_dir, 'action_distributions.png'), dpi=300, bbox_inches='tight')
        if show_plots:
            plt.show()
        else:
            plt.close()
    
    # Plot 4: Observation statistics summary
    if obs_columns:
        fig, axes = plt.subplots(2, 2, figsize=(12, 8))
        
        # Mean values over time (rolling window)
        window_size = max(1, len(df) // 20)  # 5% of data
        obs_data = df[obs_columns]
        rolling_mean = obs_data.rolling(window=window_size, center=True).mean()
        rolling_std = obs_data.rolling(window=window_size, center=True).std()
        
        # Plot mean
        axes[0, 0].plot(df['sim_time'], rolling_mean.mean(axis=1), 'b-', linewidth=2)
        axes[0, 0].set_title('Rolling Mean of All Observations')
        axes[0, 0].set_xlabel('Simulation Time (s)')
        axes[0, 0].set_ylabel('Mean Value')
        axes[0, 0].grid(True, alpha=0.3)
        
        # Plot std
        axes[0, 1].plot(df['sim_time'], rolling_std.mean(axis=1), 'r-', linewidth=2)
        axes[0, 1].set_title('Rolling Std of All Observations')
        axes[0, 1].set_xlabel('Simulation Time (s)')
        axes[0, 1].set_ylabel('Standard Deviation')
        axes[0, 1].grid(True, alpha=0.3)
        
        # Plot observation ranges
        obs_ranges = obs_data.max() - obs_data.min()
        axes[1, 0].bar(range(len(obs_ranges)), obs_ranges)
        axes[1, 0].set_title('Observation Value Ranges')
        axes[1, 0].set_xlabel('Observation Index')
        axes[1, 0].set_ylabel('Range (Max - Min)')
        axes[1, 0].grid(True, alpha=0.3)
        
        # Plot correlation matrix (if not too many observations)
        if len(obs_columns) <= 20:
            corr_matrix = obs_data.corr()
            im = axes[1, 1].imshow(corr_matrix, cmap='coolwarm', vmin=-1, vmax=1)
            axes[1, 1].set_title('Observation Correlation Matrix')
            axes[1, 1].set_xticks(range(len(obs_columns)))
            axes[1, 1].set_yticks(range(len(obs_columns)))
            axes[1, 1].set_xticklabels([f'obs_{i}' for i in range(len(obs_columns))], rotation=45)
            axes[1, 1].set_yticklabels([f'obs_{i}' for i in range(len(obs_columns))])
            plt.colorbar(im, ax=axes[1, 1])
        else:
            axes[1, 1].text(0.5, 0.5, f'Too many observations\n({len(obs_columns)}) for\ncorrelation matrix', 
                           ha='center', va='center', transform=axes[1, 1].transAxes)
            axes[1, 1].set_title('Observation Correlation Matrix')
        
        plt.tight_layout()
        
        if output_dir:
            plt.savefig(os.path.join(output_dir, 'observation_statistics.png'), dpi=300, bbox_inches='tight')
        if show_plots:
            plt.show()
        else:
            plt.close()
    
    # Print summary statistics
    print("\n" + "="*50)
    print("SUMMARY STATISTICS")
    print("="*50)
    
    if obs_columns:
        print(f"\nObservations ({len(obs_columns)} dimensions):")
        obs_stats = df[obs_columns].describe()
        print(obs_stats)
    
    if action_columns:
        print(f"\nActions ({len(action_columns)} dimensions):")
        action_stats = df[action_columns].describe()
        print(action_stats)
    
    print(f"\nSimulation Duration: {df['sim_time'].iloc[-1]:.3f} seconds")
    print(f"Total Timesteps: {len(df)}")
    print(f"Average Step Time: {df['sim_time'].iloc[-1] / len(df):.6f} seconds")

def find_latest_csv(logs_dir):
    """Find the most recently created CSV file in the logs directory"""
    csv_files = []
    
    # Search through all subdirectories for CSV files
    for root, dirs, files in os.walk(logs_dir):
        for file in files:
            if file.startswith('observations_actions_') and file.endswith('.csv'):
                csv_path = os.path.join(root, file)
                csv_files.append((csv_path, os.path.getmtime(csv_path)))
    
    if not csv_files:
        return None
    
    # Return the most recently modified CSV file
    latest_csv = max(csv_files, key=lambda x: x[1])
    return latest_csv[0]

def main():
    parser = argparse.ArgumentParser(description="Plot observations and actions from CSV logs")
    parser.add_argument("--csv_path", type=str, help="Path to the CSV file to plot")
    parser.add_argument("--logs_dir", type=str, default="logs", 
                       help="Directory to search for CSV files (default: logs)")
    parser.add_argument("--output_dir", type=str, help="Directory to save plots")
    parser.add_argument("--no_show", action="store_true", help="Don't display plots interactively")
    
    args = parser.parse_args()
    
    # Determine CSV file to plot
    if args.csv_path:
        csv_path = args.csv_path
    else:
        print(f"Searching for latest CSV file in {args.logs_dir}...")
        csv_path = find_latest_csv(args.logs_dir)
        if csv_path is None:
            print(f"No CSV files found in {args.logs_dir}")
            print("Please specify a CSV file with --csv_path or ensure CSV files exist in the logs directory")
            return
        print(f"Found latest CSV file: {csv_path}")
    
    if not os.path.exists(csv_path):
        print(f"Error: CSV file not found: {csv_path}")
        return
    
    # Set output directory
    output_dir = args.output_dir
    if output_dir is None and not args.no_show:
        # Create output directory next to CSV file
        csv_dir = os.path.dirname(csv_path)
        output_dir = os.path.join(csv_dir, "plots")
    
    # Generate plots
    plot_csv_data(csv_path, output_dir, show_plots=not args.no_show)
    
    if output_dir:
        print(f"\nPlots saved to: {output_dir}")

if __name__ == "__main__":
    main()
