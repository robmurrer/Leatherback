#!/usr/bin/env python3
"""
Script to plot observations and actions data from CSV logs generated by play.py
"""

import argparse
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
from pathlib import Path
import seaborn as sns
import base64
from io import BytesIO

def plot_to_base64(fig):
    """Convert matplotlib figure to base64 string for HTML embedding"""
    buffer = BytesIO()
    fig.savefig(buffer, format='png', dpi=300, bbox_inches='tight')
    buffer.seek(0)
    plot_data = buffer.getvalue()
    buffer.close()
    
    # Encode to base64
    plot_base64 = base64.b64encode(plot_data).decode()
    return f"data:image/png;base64,{plot_base64}"

def plot_csv_data(csv_path, show_plots=True):
    """
    Plot observations and actions: time series, boxplots, and generate HTML table with real data
    Output directory is automatically determined from CSV path and timestamp
    """
    # Read the CSV data
    print(f"Loading data from: {csv_path}")
    df = pd.read_csv(csv_path)
    
    # Extract observations, actions, and position columns
    obs_columns = [col for col in df.columns if col.startswith('obs_')]
    action_columns = [col for col in df.columns if col.startswith('action_')]
    position_columns = [col for col in df.columns if col.startswith('pos_')]
    
    print(f"Found {len(obs_columns)} observation dimensions and {len(action_columns)} action dimensions")
    print(f"Found {len(position_columns)} position coordinates: {position_columns}")
    print(f"Total timesteps: {len(df)}")
    
    # Create output directory based on CSV location and timestamp
    csv_dir = os.path.dirname(csv_path)
    csv_filename = os.path.basename(csv_path)
    timestamp = csv_filename.replace('observations_actions_', '').replace('.csv', '')
    output_dir = os.path.join(csv_dir, f"analysis_{timestamp}")
    os.makedirs(output_dir, exist_ok=True)
    
    # Set up the plotting style
    plt.style.use('seaborn-v0_8')
    sns.set_palette("husl")
    
    # Dictionary to store plot paths for HTML embedding
    plot_images = {}
    
    # Create separate plots
    
    # Plot 1: Observations time series
    if obs_columns:
        fig, ax = plt.subplots(figsize=(12, 6))
        plot_obs = obs_columns[:10] if len(obs_columns) > 10 else obs_columns
        for i, col in enumerate(plot_obs):
            ax.plot(df['sim_time'], df[col], label=col, alpha=0.8, linewidth=1.5)
        
        ax.set_xlabel('Simulation Time (s)')
        ax.set_ylabel('Observation Values')
        ax.set_title(f'Observations Over Time ({len(plot_obs)} dimensions)')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # Save plot and get base64
        plot_images['observations'] = plot_to_base64(fig)
        
        obs_plot_path = os.path.join(output_dir, 'observations_timeseries.png')
        plt.savefig(obs_plot_path, dpi=300, bbox_inches='tight')
        plt.close()
        print(f"Observations time series saved to: {obs_plot_path}")
    
    # Plot 2: Actions time series
    if action_columns:
        fig, ax = plt.subplots(figsize=(12, 6))
        for i, col in enumerate(action_columns):
            ax.plot(df['sim_time'], df[col], label=col, linewidth=2)
        
        ax.set_xlabel('Simulation Time (s)')
        ax.set_ylabel('Action Values')
        ax.set_title(f'Actions Over Time ({len(action_columns)} dimensions)')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # Save plot and get base64
        plot_images['actions'] = plot_to_base64(fig)
        
        act_plot_path = os.path.join(output_dir, 'actions_timeseries.png')
        plt.savefig(act_plot_path, dpi=300, bbox_inches='tight')
        plt.close()
        print(f"Actions time series saved to: {act_plot_path}")
    
    # Plot 3: Robot coordinates (X, Y, Z positions)
    if position_columns:
        # 3D trajectory plot
        if 'pos_x' in df.columns and 'pos_y' in df.columns and 'pos_z' in df.columns:
            fig = plt.figure(figsize=(15, 5))
            
            # 3D trajectory
            ax1 = fig.add_subplot(131, projection='3d')
            ax1.plot(df['pos_x'], df['pos_y'], df['pos_z'], 'b-', alpha=0.7, linewidth=1)
            ax1.scatter(df['pos_x'].iloc[0], df['pos_y'].iloc[0], df['pos_z'].iloc[0], 
                       color='green', s=100, label='Start')
            ax1.scatter(df['pos_x'].iloc[-1], df['pos_y'].iloc[-1], df['pos_z'].iloc[-1], 
                       color='red', s=100, label='End')
            ax1.set_xlabel('X Position (m)')
            ax1.set_ylabel('Y Position (m)')
            ax1.set_zlabel('Z Position (m)')
            ax1.set_title('3D Robot Trajectory')
            ax1.legend()
            
            # XY trajectory (top view)
            ax2 = fig.add_subplot(132)
            ax2.plot(df['pos_x'], df['pos_y'], 'b-', alpha=0.7, linewidth=1)
            ax2.scatter(df['pos_x'].iloc[0], df['pos_y'].iloc[0], color='green', s=100, label='Start')
            ax2.scatter(df['pos_x'].iloc[-1], df['pos_y'].iloc[-1], color='red', s=100, label='End')
            ax2.set_xlabel('X Position (m)')
            ax2.set_ylabel('Y Position (m)')
            ax2.set_title('XY Trajectory (Top View)')
            ax2.legend()
            ax2.grid(True, alpha=0.3)
            ax2.axis('equal')
            
            # Z position over time
            ax3 = fig.add_subplot(133)
            ax3.plot(df['sim_time'], df['pos_z'], 'r-', linewidth=2, label='Z Position')
            ax3.set_xlabel('Simulation Time (s)')
            ax3.set_ylabel('Z Position (m)')
            ax3.set_title('Z Position Over Time')
            ax3.legend()
            ax3.grid(True, alpha=0.3)
            
            # Highlight Z position issues
            z_mean = df['pos_z'].mean()
            z_std = df['pos_z'].std()
            z_threshold = 3 * z_std  # 3-sigma rule
            
            if z_std > 0.01:  # If there's significant Z variation
                ax3.axhline(y=z_mean + z_threshold, color='orange', linestyle='--', alpha=0.7, label=f'+3œÉ ({z_mean + z_threshold:.3f})')
                ax3.axhline(y=z_mean - z_threshold, color='orange', linestyle='--', alpha=0.7, label=f'-3œÉ ({z_mean - z_threshold:.3f})')
                ax3.axhline(y=z_mean, color='green', linestyle='--', alpha=0.7, label=f'Mean ({z_mean:.3f})')
                ax3.legend()
            
            plt.tight_layout()
            
            # Save plot and get base64
            plot_images['coordinates'] = plot_to_base64(fig)
            
            coord_plot_path = os.path.join(output_dir, 'robot_coordinates.png')
            plt.savefig(coord_plot_path, dpi=300, bbox_inches='tight')
            plt.close()
            print(f"Robot coordinates plot saved to: {coord_plot_path}")
        
        # Individual coordinate time series
        fig, axes = plt.subplots(3, 1, figsize=(12, 10), sharex=True)
        
        for i, coord in enumerate(['pos_x', 'pos_y', 'pos_z']):
            if coord in df.columns:
                axes[i].plot(df['sim_time'], df[coord], linewidth=2, label=coord.upper())
                axes[i].set_ylabel(f'{coord.upper()} (m)')
                axes[i].set_title(f'{coord.upper()} Position Over Time')
                axes[i].grid(True, alpha=0.3)
                axes[i].legend()
                
                # Add statistics to the plot
                mean_val = df[coord].mean()
                std_val = df[coord].std()
                min_val = df[coord].min()
                max_val = df[coord].max()
                
                axes[i].axhline(y=mean_val, color='red', linestyle='--', alpha=0.7, 
                               label=f'Mean: {mean_val:.3f}m')
                
                # Add text box with statistics
                stats_text = f'Mean: {mean_val:.3f}m\nStd: {std_val:.3f}m\nMin: {min_val:.3f}m\nMax: {max_val:.3f}m\nRange: {max_val-min_val:.3f}m'
                axes[i].text(0.02, 0.98, stats_text, transform=axes[i].transAxes, 
                            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
        
        axes[-1].set_xlabel('Simulation Time (s)')
        plt.tight_layout()
        
        # Save plot and get base64
        plot_images['coordinates_timeseries'] = plot_to_base64(fig)
        
        coord_timeseries_path = os.path.join(output_dir, 'coordinates_timeseries.png')
        plt.savefig(coord_timeseries_path, dpi=300, bbox_inches='tight')
        plt.close()
        print(f"Coordinates time series saved to: {coord_timeseries_path}")
    
    # Plot 4: Combined boxplots (now including positions)
    if obs_columns or action_columns or position_columns:
        fig, axes = plt.subplots(1, 3, figsize=(20, 6))
        
        # Observations boxplot
        if obs_columns:
            plot_obs = obs_columns[:15] if len(obs_columns) > 15 else obs_columns
            obs_data = [df[col] for col in plot_obs]
            box_plot1 = axes[0].boxplot(obs_data, labels=plot_obs, patch_artist=True)
            
            colors1 = plt.cm.Set3(np.linspace(0, 1, len(plot_obs)))
            for patch, color in zip(box_plot1['boxes'], colors1):
                patch.set_facecolor(color)
                patch.set_alpha(0.7)
            
            axes[0].set_xlabel('Observation Dimensions')
            axes[0].set_ylabel('Values')
            axes[0].set_title('Observations Distribution')
            axes[0].grid(True, alpha=0.3)
            axes[0].tick_params(axis='x', rotation=45, labelsize=8)
        
        # Actions boxplot
        if action_columns:
            action_data = [df[col] for col in action_columns]
            box_plot2 = axes[1].boxplot(action_data, labels=action_columns, patch_artist=True)
            
            colors2 = plt.cm.Set2(np.linspace(0, 1, len(action_columns)))
            for patch, color in zip(box_plot2['boxes'], colors2):
                patch.set_facecolor(color)
                patch.set_alpha(0.7)
            
            axes[1].set_xlabel('Action Dimensions')
            axes[1].set_ylabel('Values')
            axes[1].set_title('Actions Distribution')
            axes[1].grid(True, alpha=0.3)
            axes[1].tick_params(axis='x', rotation=45, labelsize=8)
        
        # Position coordinates boxplot
        if position_columns:
            position_data = [df[col] for col in position_columns]
            box_plot3 = axes[2].boxplot(position_data, labels=position_columns, patch_artist=True)
            
            colors3 = plt.cm.Set1(np.linspace(0, 1, len(position_columns)))
            for patch, color in zip(box_plot3['boxes'], colors3):
                patch.set_facecolor(color)
                patch.set_alpha(0.7)
            
            axes[2].set_xlabel('Position Coordinates')
            axes[2].set_ylabel('Values (m)')
            axes[2].set_title('Position Coordinates Distribution')
            axes[2].grid(True, alpha=0.3)
            axes[2].tick_params(axis='x', rotation=45, labelsize=8)
            
            # Add statistics text for Z position if it exists
            if 'pos_z' in df.columns:
                z_stats = f'Z Stats:\nMean: {df["pos_z"].mean():.3f}m\nStd: {df["pos_z"].std():.3f}m\nRange: {df["pos_z"].max() - df["pos_z"].min():.3f}m'
                axes[2].text(0.02, 0.98, z_stats, transform=axes[2].transAxes, 
                            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='yellow', alpha=0.8))
        
        plt.tight_layout()
        
        # Save plot and get base64
        plot_images['boxplots'] = plot_to_base64(fig)
        
        boxplot_path = os.path.join(output_dir, 'boxplots.png')
        plt.savefig(boxplot_path, dpi=300, bbox_inches='tight')
        plt.close()
        print(f"Boxplots saved to: {boxplot_path}")
    
    # Generate HTML table with real data and embedded plots
    generate_html_table(df, obs_columns, action_columns, position_columns, output_dir, timestamp, plot_images)
    
    return output_dir

def generate_html_table(df, obs_columns, action_columns, position_columns, output_dir, timestamp, plot_images):
    """Generate HTML file with real data table and embedded plots"""
    
    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Robot Analysis - {timestamp}</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 20px; background-color: #f8f9fa; }}
            h1 {{ color: #333; text-align: center; }}
            h2 {{ color: #666; margin-top: 30px; border-bottom: 2px solid #ddd; padding-bottom: 5px; }}
            table {{ border-collapse: collapse; width: 100%; margin-top: 20px; background-color: white; }}
            th, td {{ border: 1px solid #ddd; padding: 8px; text-align: center; }}
            th {{ background-color: #f2f2f2; font-weight: bold; }}
            .obs-col {{ background-color: #e3f2fd; }}
            .act-col {{ background-color: #fff3e0; }}
            .pos-col {{ background-color: #e8f5e8; }}
            .stats-table {{ margin-top: 20px; }}
            .info {{ background-color: white; padding: 15px; border-radius: 5px; margin: 20px 0; border-left: 4px solid #007bff; }}
            .data-table {{ max-height: 600px; overflow-y: auto; }}
            .plot-container {{ text-align: center; margin: 20px 0; background-color: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
            .plot-container img {{ max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px; }}
            .warning {{ color: red; font-weight: bold; }}
        </style>
    </head>
    <body>
        <h1>ü§ñ Robot Analysis Report - {timestamp}</h1>
        
        <div class="info">
            <h3>üìä Dataset Summary</h3>
            <p><strong>Total Timesteps:</strong> {len(df)}</p>
            <p><strong>Simulation Duration:</strong> {df['sim_time'].iloc[-1]:.3f} seconds</p>
            <p><strong>Observations:</strong> {len(obs_columns)} dimensions</p>
            <p><strong>Actions:</strong> {len(action_columns)} dimensions</p>
            <p><strong>Position Coordinates:</strong> {len(position_columns)} dimensions</p>
            <p><strong>Average Step Time:</strong> {df['sim_time'].iloc[-1] / len(df):.6f} seconds</p>
        </div>
        
        <h2>Position Coordinate Analysis</h2>
        <div class="info">
    """
    
    # Add position coordinate analysis
    if position_columns:
        for pos_col in position_columns:
            if pos_col in df.columns:
                mean_val = df[pos_col].mean()
                std_val = df[pos_col].std()
                min_val = df[pos_col].min()
                max_val = df[pos_col].max()
                range_val = max_val - min_val
                
                html_content += f"""
            <p><strong>{pos_col.upper()}:</strong> Mean={mean_val:.3f}m, Std={std_val:.3f}m, Range={range_val:.3f}m (Min={min_val:.3f}m, Max={max_val:.3f}m)</p>
                """
                
                # Highlight potential Z position issues
                if pos_col == 'pos_z' and (std_val > 0.1 or range_val > 0.2):
                    html_content += f"""
            <p class="warning">‚ö†Ô∏è Z Position Issue Detected: High variation in Z coordinate (Std={std_val:.3f}m, Range={range_val:.3f}m)</p>
                    """
    
    html_content += """
        </div>
        
        <h2>üìà Visualization Plots</h2>
    """
    
    # Add embedded plots
    if 'observations' in plot_images:
        html_content += f"""
        <div class="plot-container">
            <h3>Observations Time Series</h3>
            <img src="{plot_images['observations']}" alt="Observations Time Series">
        </div>
        """
    
    if 'actions' in plot_images:
        html_content += f"""
        <div class="plot-container">
            <h3>Actions Time Series</h3>
            <img src="{plot_images['actions']}" alt="Actions Time Series">
        </div>
        """
    
    if 'coordinates' in plot_images:
        html_content += f"""
        <div class="plot-container">
            <h3>Robot 3D Trajectory & Position Analysis</h3>
            <img src="{plot_images['coordinates']}" alt="Robot Coordinates">
        </div>
        """
    
    if 'coordinates_timeseries' in plot_images:
        html_content += f"""
        <div class="plot-container">
            <h3>Position Coordinates Over Time</h3>
            <img src="{plot_images['coordinates_timeseries']}" alt="Coordinates Time Series">
        </div>
        """
    
    if 'boxplots' in plot_images:
        html_content += f"""
        <div class="plot-container">
            <h3>Data Distribution (Box Plots)</h3>
            <img src="{plot_images['boxplots']}" alt="Box Plots">
        </div>
        """
    
    html_content += """
        
        <h2>üìä Statistics Summary</h2>
        <div class="stats-table">
    """
    
    # Add statistics table
    all_columns = obs_columns + action_columns + position_columns
    html_content += """
            <table>
                <tr>
                    <th>Variable</th>
                    <th>Type</th>
                    <th>Mean</th>
                    <th>Std</th>
                    <th>Min</th>
                    <th>Max</th>
                    <th>Median</th>
                    <th>Q25</th>
                    <th>Q75</th>
                </tr>
    """
    
    for col in all_columns:
        if col.startswith('obs_'):
            var_type = 'Observation'
            css_class = 'obs-col'
        elif col.startswith('action_'):
            var_type = 'Action'
            css_class = 'act-col'
        elif col.startswith('pos_'):
            var_type = 'Position'
            css_class = 'pos-col'
        else:
            var_type = 'Other'
            css_class = ''
        html_content += f"""
                <tr>
                    <td class="{css_class}"><strong>{col}</strong></td>
                    <td class="{css_class}">{var_type}</td>
                    <td class="{css_class}">{df[col].mean():.6f}</td>
                    <td class="{css_class}">{df[col].std():.6f}</td>
                    <td class="{css_class}">{df[col].min():.6f}</td>
                    <td class="{css_class}">{df[col].max():.6f}</td>
                    <td class="{css_class}">{df[col].median():.6f}</td>
                    <td class="{css_class}">{df[col].quantile(0.25):.6f}</td>
                    <td class="{css_class}">{df[col].quantile(0.75):.6f}</td>
                </tr>
        """
    
    html_content += """
            </table>
        </div>
        
        <h2>Complete Data Table (All Timesteps)</h2>
        <div class="data-table">
            <table>
                <tr>
                    <th>Timestep</th>
                    <th>Sim Time (s)</th>
    """
    
    # Add column headers
    for col in obs_columns:
        html_content += f'<th class="obs-col">{col}</th>'
    for col in action_columns:
        html_content += f'<th class="act-col">{col}</th>'
    for col in position_columns:
        html_content += f'<th class="pos-col">{col}</th>'
    
    html_content += "</tr>"
    
    # Add all data rows
    for idx, row in df.iterrows():
        html_content += f"""
                <tr>
                    <td>{row['timestep']:.0f}</td>
                    <td>{row['sim_time']:.4f}</td>
        """
        
        for col in obs_columns:
            html_content += f'<td class="obs-col">{row[col]:.6f}</td>'
        for col in action_columns:
            html_content += f'<td class="act-col">{row[col]:.6f}</td>'
        for col in position_columns:
            html_content += f'<td class="pos-col">{row[col]:.6f}</td>'
        
        html_content += "</tr>"
    
    html_content += """
            </table>
        </div>
        
        <div class="info">
            <p><em>Generated on: """ + timestamp + """</em></p>
            <p><em>Observations are highlighted in blue, Actions in orange, Positions in green</em></p>
            <p><em>All plots are embedded as high-resolution images for analysis</em></p>
        </div>
        
    </body>
    </html>
    """
    
    # Save HTML file with timestamp-based name
    html_filename = f"robot_analysis_{timestamp}.html"
    html_path = os.path.join(output_dir, html_filename)
    with open(html_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    print(f"üéâ Complete HTML analysis report saved to: {html_path}")
    print(f"üåê Open in browser: file://{os.path.abspath(html_path)}")

def find_latest_csv(logs_dir):
    """Find the most recently created CSV file in the logs directory"""
    csv_files = []
    
    # Search through all subdirectories for CSV files
    for root, dirs, files in os.walk(logs_dir):
        for file in files:
            if file.startswith('observations_actions_') and file.endswith('.csv'):
                csv_path = os.path.join(root, file)
                csv_files.append((csv_path, os.path.getmtime(csv_path)))
    
    if not csv_files:
        return None
    
    # Return the most recently modified CSV file
    latest_csv = max(csv_files, key=lambda x: x[1])
    return latest_csv[0]

def main():
    parser = argparse.ArgumentParser(description="Plot observations and actions from CSV logs")
    parser.add_argument("--csv_path", type=str, help="Path to the CSV file to plot")
    parser.add_argument("--logs_dir", type=str, default="logs", 
                       help="Directory to search for CSV files (default: logs)")
    
    args = parser.parse_args()
    
    # Determine CSV file to plot
    if args.csv_path:
        csv_path = args.csv_path
    else:
        print(f"Searching for latest CSV file in {args.logs_dir}...")
        csv_path = find_latest_csv(args.logs_dir)
        if csv_path is None:
            print(f"No CSV files found in {args.logs_dir}")
            print("Please specify a CSV file with --csv_path or ensure CSV files exist in the logs directory")
            return
        print(f"Found latest CSV file: {csv_path}")
    
    if not os.path.exists(csv_path):
        print(f"Error: CSV file not found: {csv_path}")
        return
    
    # Generate complete analysis (no display, save only)
    output_dir = plot_csv_data(csv_path, show_plots=False)
    
    print(f"\nAnalysis complete! Files saved to: {output_dir}")

if __name__ == "__main__":
    main()
