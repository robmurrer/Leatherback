#!/usr/bin/env python3
"""
Script to plot observations and actions data from CSV logs generated by play.py
"""

import argparse
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
from pathlib import Path
import seaborn as sns

def plot_csv_data(csv_path, show_plots=True):
    """
    Plot observations and actions: time series, boxplots, and generate HTML table with real data
    Output directory is automatically determined from CSV path and timestamp
    """
    # Read the CSV data
    print(f"Loading data from: {csv_path}")
    df = pd.read_csv(csv_path)
    
    # Extract observations and actions columns
    obs_columns = [col for col in df.columns if col.startswith('obs_')]
    action_columns = [col for col in df.columns if col.startswith('action_')]
    
    print(f"Found {len(obs_columns)} observation dimensions and {len(action_columns)} action dimensions")
    print(f"Total timesteps: {len(df)}")
    
    # Create output directory based on CSV location and timestamp
    csv_dir = os.path.dirname(csv_path)
    csv_filename = os.path.basename(csv_path)
    timestamp = csv_filename.replace('observations_actions_', '').replace('.csv', '')
    output_dir = os.path.join(csv_dir, f"analysis_{timestamp}")
    os.makedirs(output_dir, exist_ok=True)
    
    # Set up the plotting style
    plt.style.use('seaborn-v0_8')
    sns.set_palette("husl")
    
    # Create separate plots
    
    # Plot 1: Observations time series
    if obs_columns:
        fig, ax = plt.subplots(figsize=(12, 6))
        plot_obs = obs_columns[:10] if len(obs_columns) > 10 else obs_columns
        for i, col in enumerate(plot_obs):
            ax.plot(df['sim_time'], df[col], label=col, alpha=0.8, linewidth=1.5)
        
        ax.set_xlabel('Simulation Time (s)')
        ax.set_ylabel('Observation Values')
        ax.set_title(f'Observations Over Time ({len(plot_obs)} dimensions)')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        obs_plot_path = os.path.join(output_dir, 'observations_timeseries.png')
        plt.savefig(obs_plot_path, dpi=300, bbox_inches='tight')
        plt.close()
        print(f"Observations time series saved to: {obs_plot_path}")
    
    # Plot 2: Actions time series
    if action_columns:
        fig, ax = plt.subplots(figsize=(12, 6))
        for i, col in enumerate(action_columns):
            ax.plot(df['sim_time'], df[col], label=col, linewidth=2)
        
        ax.set_xlabel('Simulation Time (s)')
        ax.set_ylabel('Action Values')
        ax.set_title(f'Actions Over Time ({len(action_columns)} dimensions)')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        act_plot_path = os.path.join(output_dir, 'actions_timeseries.png')
        plt.savefig(act_plot_path, dpi=300, bbox_inches='tight')
        plt.close()
        print(f"Actions time series saved to: {act_plot_path}")
    
    # Plot 3: Combined boxplots
    if obs_columns or action_columns:
        fig, axes = plt.subplots(1, 2, figsize=(16, 6))
        
        # Observations boxplot
        if obs_columns:
            plot_obs = obs_columns[:15] if len(obs_columns) > 15 else obs_columns
            obs_data = [df[col] for col in plot_obs]
            box_plot1 = axes[0].boxplot(obs_data, labels=plot_obs, patch_artist=True)
            
            colors1 = plt.cm.Set3(np.linspace(0, 1, len(plot_obs)))
            for patch, color in zip(box_plot1['boxes'], colors1):
                patch.set_facecolor(color)
                patch.set_alpha(0.7)
            
            axes[0].set_xlabel('Observation Dimensions')
            axes[0].set_ylabel('Values')
            axes[0].set_title('Observations Distribution')
            axes[0].grid(True, alpha=0.3)
            axes[0].tick_params(axis='x', rotation=45, labelsize=8)
        
        # Actions boxplot
        if action_columns:
            action_data = [df[col] for col in action_columns]
            box_plot2 = axes[1].boxplot(action_data, labels=action_columns, patch_artist=True)
            
            colors2 = plt.cm.Set2(np.linspace(0, 1, len(action_columns)))
            for patch, color in zip(box_plot2['boxes'], colors2):
                patch.set_facecolor(color)
                patch.set_alpha(0.7)
            
            axes[1].set_xlabel('Action Dimensions')
            axes[1].set_ylabel('Values')
            axes[1].set_title('Actions Distribution')
            axes[1].grid(True, alpha=0.3)
            axes[1].tick_params(axis='x', rotation=45, labelsize=8)
        
        plt.tight_layout()
        boxplot_path = os.path.join(output_dir, 'boxplots.png')
        plt.savefig(boxplot_path, dpi=300, bbox_inches='tight')
        plt.close()
        print(f"Boxplots saved to: {boxplot_path}")
    
    # Generate HTML table with real data
    generate_html_table(df, obs_columns, action_columns, output_dir, timestamp)
    
    return output_dir

def generate_html_table(df, obs_columns, action_columns, output_dir, timestamp):
    """Generate HTML file with real data table"""
    
    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Observations and Actions Data - {timestamp}</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 20px; }}
            h1 {{ color: #333; }}
            h2 {{ color: #666; margin-top: 30px; }}
            table {{ border-collapse: collapse; width: 100%; margin-top: 20px; }}
            th, td {{ border: 1px solid #ddd; padding: 8px; text-align: center; }}
            th {{ background-color: #f2f2f2; font-weight: bold; }}
            .obs-col {{ background-color: #e3f2fd; }}
            .act-col {{ background-color: #fff3e0; }}
            .stats-table {{ margin-top: 20px; }}
            .info {{ background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0; }}
            .data-table {{ max-height: 600px; overflow-y: auto; }}
        </style>
    </head>
    <body>
        <h1>Observations and Actions Analysis - {timestamp}</h1>
        
        <div class="info">
            <h3>Dataset Info</h3>
            <p><strong>Total Timesteps:</strong> {len(df)}</p>
            <p><strong>Simulation Duration:</strong> {df['sim_time'].iloc[-1]:.3f} seconds</p>
            <p><strong>Observations:</strong> {len(obs_columns)} dimensions</p>
            <p><strong>Actions:</strong> {len(action_columns)} dimensions</p>
            <p><strong>Average Step Time:</strong> {df['sim_time'].iloc[-1] / len(df):.6f} seconds</p>
        </div>
        
        <h2>Statistics Summary</h2>
        <div class="stats-table">
    """
    
    # Add statistics table
    all_columns = obs_columns + action_columns
    html_content += """
            <table>
                <tr>
                    <th>Variable</th>
                    <th>Type</th>
                    <th>Mean</th>
                    <th>Std</th>
                    <th>Min</th>
                    <th>Max</th>
                    <th>Median</th>
                    <th>Q25</th>
                    <th>Q75</th>
                </tr>
    """
    
    for col in all_columns:
        var_type = 'Observation' if col.startswith('obs_') else 'Action'
        css_class = 'obs-col' if col.startswith('obs_') else 'act-col'
        html_content += f"""
                <tr>
                    <td class="{css_class}"><strong>{col}</strong></td>
                    <td class="{css_class}">{var_type}</td>
                    <td class="{css_class}">{df[col].mean():.6f}</td>
                    <td class="{css_class}">{df[col].std():.6f}</td>
                    <td class="{css_class}">{df[col].min():.6f}</td>
                    <td class="{css_class}">{df[col].max():.6f}</td>
                    <td class="{css_class}">{df[col].median():.6f}</td>
                    <td class="{css_class}">{df[col].quantile(0.25):.6f}</td>
                    <td class="{css_class}">{df[col].quantile(0.75):.6f}</td>
                </tr>
        """
    
    html_content += """
            </table>
        </div>
        
        <h2>Complete Data Table (All Timesteps)</h2>
        <div class="data-table">
            <table>
                <tr>
                    <th>Timestep</th>
                    <th>Sim Time (s)</th>
    """
    
    # Add column headers
    for col in obs_columns:
        html_content += f'<th class="obs-col">{col}</th>'
    for col in action_columns:
        html_content += f'<th class="act-col">{col}</th>'
    
    html_content += "</tr>"
    
    # Add all data rows
    for idx, row in df.iterrows():
        html_content += f"""
                <tr>
                    <td>{row['timestep']:.0f}</td>
                    <td>{row['sim_time']:.4f}</td>
        """
        
        for col in obs_columns:
            html_content += f'<td class="obs-col">{row[col]:.6f}</td>'
        for col in action_columns:
            html_content += f'<td class="act-col">{row[col]:.6f}</td>'
        
        html_content += "</tr>"
    
    html_content += """
            </table>
        </div>
        
        <div class="info">
            <p><em>Generated on: {timestamp}</em></p>
            <p><em>Observations are highlighted in blue, Actions in orange</em></p>
        </div>
        
    </body>
    </html>
    """
    
    # Save HTML file
    html_path = os.path.join(output_dir, 'data_table.html')
    with open(html_path, 'w') as f:
        f.write(html_content)
    
    print(f"HTML data table saved to: {html_path}")
    print(f"Open in browser: file://{os.path.abspath(html_path)}")

def find_latest_csv(logs_dir):
    """Find the most recently created CSV file in the logs directory"""
    csv_files = []
    
    # Search through all subdirectories for CSV files
    for root, dirs, files in os.walk(logs_dir):
        for file in files:
            if file.startswith('observations_actions_') and file.endswith('.csv'):
                csv_path = os.path.join(root, file)
                csv_files.append((csv_path, os.path.getmtime(csv_path)))
    
    if not csv_files:
        return None
    
    # Return the most recently modified CSV file
    latest_csv = max(csv_files, key=lambda x: x[1])
    return latest_csv[0]

def main():
    parser = argparse.ArgumentParser(description="Plot observations and actions from CSV logs")
    parser.add_argument("--csv_path", type=str, help="Path to the CSV file to plot")
    parser.add_argument("--logs_dir", type=str, default="logs", 
                       help="Directory to search for CSV files (default: logs)")
    
    args = parser.parse_args()
    
    # Determine CSV file to plot
    if args.csv_path:
        csv_path = args.csv_path
    else:
        print(f"Searching for latest CSV file in {args.logs_dir}...")
        csv_path = find_latest_csv(args.logs_dir)
        if csv_path is None:
            print(f"No CSV files found in {args.logs_dir}")
            print("Please specify a CSV file with --csv_path or ensure CSV files exist in the logs directory")
            return
        print(f"Found latest CSV file: {csv_path}")
    
    if not os.path.exists(csv_path):
        print(f"Error: CSV file not found: {csv_path}")
        return
    
    # Generate complete analysis (no display, save only)
    output_dir = plot_csv_data(csv_path, show_plots=False)
    
    print(f"\nAnalysis complete! Files saved to: {output_dir}")

if __name__ == "__main__":
    main()
